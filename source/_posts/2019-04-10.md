---
title: 【golang】 学习笔记
date: 2019-4-10 16:00
tags: 工具
keywords:  go golang 
---

# 1. 函数参数
-------------
```
1、Go 默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量
2、如果你希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加&符号，比如 &variable）传递给函数，
这就是按引用传递,此时传递给函数的是一个指针。如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；
我们可以通过这个指针的值来修改这个值所指向的地址上的值,指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递
3、几乎在任何情况下，传递指针（一个32位或者64位的值）的消耗都比传递副本来得少。
4、在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显式的指出指针）。
```
<!-- more -->
示例：
```go
    // A: 
    func DoSomething(a *A) {
        b = a
    };
    // B: 
    func DoSomething(a A) {
        b = &a
    }
```
这两个 func 的区别在于 func A 中可以修改 a 的值

# 2. defer
-------------
```
1、关键字 defer 允许我们推迟到函数返回之前（或任意位置执行 return 语句之后）一刻才执行某个语句或函数
2、一般执行一些函数执行完之后的收尾工作
3、当有多个 defer 行为被注册时，它们会以逆序执行（类似栈，即后进先出）
```
# 3. for 循环修改值的问题
------------
```js
items := [...]int{10, 20, 30, 40, 50}
for _, item := range items {
    item *= 2
}
//[10, 20, 30, 40, 50]
```
item 只是 items 某个索引位置的值的一个拷贝，不能用来修改 items 该索引位置的值
想修改的话 可以通过索引获得引用来修改
```js
items := [...]int{10, 20, 30, 40, 50}
for idx, _ := range items {
    // item *= 2
    items[idx] *= 2
}
//[20 40 60 80 100]
```
# 3. append方法的常见操作
------------
```js
// 将切片 b 的元素追加到切片 a 之后
a = append(a, b...)
// 复制切片 a 的元素到新的切片 b 上
b = make([]T, len(a))
copy(b, a)
// 删除位于索引 i 的元素
a = append(a[:i], a[i+1:]...)
// 切除切片 a 中从索引 i 至 j 位置的元素
a = append(a[:i], a[j:]...)
// 为切片 a 扩展 j 个元素长度
a = append(a, make([]T, j)...)
// 在索引 i 的位置插入元素 x
a = append(a[:i], append([]T{x}, a[i:]...)...)
// 在索引 i 的位置插入长度为 j 的新切片
a = append(a[:i], append(make([]T, j), a[i:]...)...)
// 在索引 i 的位置插入切片 b 的所有元素
a = append(a[:i], append(b, a[i:]...)...)
// 取出位于切片 a 最末尾的元素 x
x, a = a[len(a)-1], a[:len(a)-1]
// 将元素 x 追加到切片 a
a = append(a, x)
```
# 4. map
------------
```
在声明的时候不需要知道 map 的长度，map 是可以动态增长的。
value 可以是任意类型的；通过使用空接口类型，我们可以存储任意值，但是使用这种类型作为值时需要先做一次类型断言
```
map 默认是无序的
```
如果你想为 map 排序，需要将 key（或者 value）拷贝到一个切片，再对切片排序（使用 sort.Strings(keys)），然后可以使用切片的 for-range 方法打印出所有的 key 和 value。
```
但是如果你想要一个排序的列表可以使用结构体切片:
```js
type name struct {
    key string
    value int
}
```

# 4. 标准库
------------
`archive/tar` 和 `/zip-compress`：压缩(解压缩)文件功能
`fmt`: 提供了格式化输入输出功能
`io`: 提供了基本输入输出功能，大多数是围绕系统功能的封装
`bufio`: 缓冲输入输出功能的封装
`path/filepath`: 用来操作在当前系统中的目标文件名路径
`flag`: 对命令行参数的操作

`strings`: 提供对字符串的操作
`strconv`: 提供将字符串转换为基础类型的功能
`unicode`: 为 unicode 型的字符串提供特殊的功能
`regexp`: 正则表达式功能
`bytes`: 提供对字符型分片的操作
`index/suffixarray`: 子字符串快速查询

`math`: 基本的数学函数
`math/cmath`: 对复数的操作
`math/rand`: 伪随机数生成
`sort`: 为数组排序和自定义集合
`math/big`: 大数的实现和计算

实现对集合的操作
`list`: 双链表
`ring`: 环形链表

`time`: 日期和时间的基本操作
`log`: 记录程序运行时产生的日志

`encoding/json`: 读取并解码和写入并编码 JSON 数据
`encoding/xml`:简单的 XML1.0 解析器
`text/template`:生成像 HTML 一样的数据与文本混合的数据驱动模板

`net`: 网络数据的基本操作
`http`: 提供了一个可扩展的 HTTP 服务器和基础客户端，解析 HTTP 请求和回复
`html`: HTML5 解析器

`runtime`: Go 程序运行时的交互操作，例如垃圾回收和协程创建
`reflect`: 实现通过程序运行时反射，让程序操作任意类型的变量